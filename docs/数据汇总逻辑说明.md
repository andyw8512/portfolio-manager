# 持仓整理工具 - 数据汇总逻辑说明

本文档按**执行顺序**列出程序从「上传截图」到「页面展示 / 导出 Excel」的每一步数据流与汇总逻辑。

---

## 一、整体流程概览

```
上传截图 → 校验 OCR 服务 → 逐张 OCR 识别 → 解析文本为持仓列表 → 写入 holdings
    → 计算总资产与行业汇总 → 渲染「所有产品汇总」+「行业占比分析」+「持仓明细表」
    → （可选）导出 Excel
```

**核心数据源**：全局数组 `holdings`，每项结构为  
`{ product, stock, value, category }`  
- `product`：产品编号，如 `'1号'`、`'2号'`（解析不到时默认 `'1号'`）  
- `stock`：标的/股票名称  
- `value`：市值（万元，来自 OCR 或 12 列表格的「持仓市值」列）  
- `category`：行业分类，来自 `categoryMap[stock]`，缺省为 `'A股资源'`

---

## 二、步骤 1：上传与触发计算

| 步骤 | 说明 |
|------|------|
| 1.1 | 用户上传「GT」和/或「TRS」截图，分别存入 `gtImages`、`trsImages`（每项含 `name`、`src` 等）。 |
| 1.2 | 点击「开始计算」或「截图转 Excel」→ 调用 `startCalculation(opts)`。若 `opts.thenExportExcel === true`，计算完成后会再调用 `exportExcel()`。 |
| 1.3 | 若无任何截图则 `alert('请先上传持仓截图！')` 并 return。 |

---

## 三、步骤 2：OCR 服务校验与识别

| 步骤 | 说明 |
|------|------|
| 2.1 | `checkOcrService()`：请求 `GET /api/version`，仅当 `version === 2` 时才继续，否则认为连到旧后端，抛错提示运行 `server.js`（3011）并刷新。 |
| 2.2 | 将 GT、TRS 图片合并为 `allImagesForOCR`，每项带 `type: 'GT'` 或 `'TRS'`。清空 `ocrHoldings`。 |
| 2.3 | 逐张调用 `recognizeImage(img.src)`：`POST /api/ocr`，body 仅 `{ image }`。后端用 MiniMax 识别，返回 `result.data`（如 `{ content: "..." }`）。 |
| 2.4 | 对每张图的 `result.data` 调用 `parseOCRResult(result, img.type)`，将返回的数组全部 push 到 `ocrHoldings`。任一张失败则提示「识别失败」并中止。 |
| 2.5 | 若 `ocrHoldings.length === 0`，提示「未识别到持仓数据…」并 return；否则执行 `holdings = [...ocrHoldings]`，进入计算与展示。 |

---

## 四、步骤 3：解析 OCR 文本（parseOCRResult）

| 步骤 | 说明 |
|------|------|
| 3.1 | **取原始文本**：优先 `ocrData.content`，否则 `words_result[].words` 拼成一行、或 `ocrData.text`、或整份 JSON 字符串。 |
| 3.2 | **按行处理**：`text.split(/\r?\n/)`，每行 trim，过滤空行。维护 `currentProduct`，默认 `'1号'`。 |
| 3.3 | **每行解析规则（按顺序尝试，命中则不再试后续）**： |
| 3.3a | 若匹配「产品X号 / X号产品 / 产品X」→ 更新 `currentProduct`，该行不再产出持仓。 |
| 3.3b | **Tab 分隔**：若行内包含 `\t`： |
|  | - 列数 ≥12：视为「互换/持仓报表」，`标的名称 = parts[3]`，`持仓市值 = parts[11]`（去逗号转 float）。表头（标的名称/持仓市值）行跳过。 |
|  | - 列数 2～11：`parts[0]` 为股票名，`parts[1]` 为市值。 |
| 3.3c | **空格分隔**：正则 `^([\u4e00-\u9fa5A-Za-z0-9]+)\s+([\d.,]+)` → 股票名、市值。 |
| 3.3d | **带「万」**：同上，允许末尾「万」。 |
| 3.4 | **写入一条持仓的条件**：`stock` 非空、`value` 为有效数字且 **value > 0**；且股票名不是「合计」「现金」或「产品X」。 |
| 3.5 | 每条持仓写入：`{ product: currentProduct, stock, value, category: categoryMap[stock] || 'A股资源' }`。 |
| 3.6 | 返回本张图解析得到的 `holdings` 数组；多张图时在 `startCalculation` 里合并到 `ocrHoldings`。 |

---

## 五、步骤 4：主计算函数（calculate）

在 `holdings` 已更新后调用，用于更新页面所有汇总与表格。

| 步骤 | 说明 |
|------|------|
| 4.1 | **总市值**：`totalMarket = holdings.reduce((sum, h) => sum + h.value, 0)`（单位：万元）。 |
| 4.2 | **总现金**：`totalCash = getTotalCash()` = 1号、2号、5号、6号四个现金输入框数值之和。 |
| 4.3 | **总资产**：`totalAssets = totalMarket + totalCash`。 |
| 4.4 | **更新「所有产品汇总」区域**：将 `totalAssets`、`totalMarket`、`totalCash`、`holdings.length` 写入对应 DOM（如 `#totalAssets`、`#totalMarket` 等）。 |
| 4.5 | **行业占比分析**：调用 `renderIndustry(totalAssets)`（见下）。 |
| 4.6 | **持仓明细表**：调用 `renderTable()`（见下）。 |
| 4.7 | **步骤指示器**：`updateSteps()` 根据是否有截图、是否有持仓数据，高亮/完成对应步骤。 |

---

## 六、步骤 5：行业占比分析（renderIndustry）

| 步骤 | 说明 |
|------|------|
| 5.1 | **按行业汇总市值**：遍历 `holdings`，`indMap[category] += value`；若无该 `category` 则先置 0 再加。 |
| 5.2 | **加入现金**：`indMap['现金'] = getTotalCash()`。 |
| 5.3 | **排序**：`Object.entries(indMap)` 按市值**降序**排序。 |
| 5.4 | **柱状图**：按排序结果遍历，每条为「行业名 + 市值(万) + 占比%」，占比 = `val / totalAssets * 100`，柱条宽度按占比绘制。 |
| 5.5 | **行业明细表**：表头「行业分类 / 市值(万) / 占比」，每行一个行业 + 其市值 + 占比%，最后一行「合计 / totalAssets / 100%」。 |

**占比口径**：所有占比的分母均为当前**总资产** `totalAssets`（总市值 + 总现金）。

---

## 七、步骤 6：持仓明细表（renderTable）

| 步骤 | 说明 |
|------|------|
| 6.1 | **按标签页过滤**：当前选中的是「1号」「2号」「5号」「6号」之一 → `filtered = holdings.filter(h => h.product === currentTab)`；选「全部汇总」→ `filtered = [...holdings]`。 |
| 6.2 | **全部汇总时的合并**：当 `currentTab === 'all'` 时，按 `stock` 合并：同名股票市值相加，得到「股票 → 合并后 value + category」；`filtered` 变为合并后的数组。 |
| 6.3 | **当前视图总资产**：`cash` = 当前产品现金（全部汇总则为总现金）；`totalMarket` = 当前 `filtered` 市值之和；`totalAsset = totalMarket + cash`。 |
| 6.4 | **表格内容**：表头「股票名称 / 市值(万) / 占比 / 行业分类」。 |
| 6.5 | 对 `filtered` 按 `value` **降序**排序，每行：股票名、市值、**占比 = 该股 value / totalAsset × 100%**、行业标签。 |
| 6.6 | 追加一行「现金」：金额 = 当前视图的 `cash`，占比 = `cash / totalAsset × 100%`。 |
| 6.7 | 最后一行「合计」：金额 = `totalAsset`，占比 100%。 |

**占比口径**：当前标签页下的「持仓市值 + 现金」为分母；全部汇总时分母为「全部持仓合并后的市值 + 总现金」。

---

## 八、步骤 7：导出 Excel（exportExcel）

仅在用户点击「截图转 Excel」或手动触发导出时执行；依赖当前 `holdings` 与各产品现金输入框。

| 步骤 | 说明 |
|------|------|
| 7.1 | 若 `holdings.length === 0`，提示「请先导入数据」并 return。 |
| 7.2 | **按产品分组导出**：固定遍历产品 `['1号', '2号', '5号', '6号']`。 |
| 7.3 | 对每个产品 `p`：`filtered = holdings.filter(h => h.product === p)`；若 `filtered.length === 0` 则跳过该产品。 |
| 7.4 | 该产品总资产：`total = filtered 市值之和 + getCash(p)`。 |
| 7.5 | 该产品块内输出：① 每条持仓一行（产品、股票名称、市值(万元)、**占比 = value/total×100%**、行业分类），按市值降序；② 一行「现金」+ 占比；③ 一行「【合计】」+ total + 100%；④ 一行空行做分隔。 |
| 7.6 | **行业汇总块**：先写一行标题行「【行业汇总】」，其余列为空。 |
| 7.7 | 全量 `totalAssets = 所有持仓市值 + getTotalCash()`；`indMap` 与 `renderIndustry` 一致：按 `category` 汇总市值，再 `indMap['现金'] = getTotalCash()`。 |
| 7.8 | 按行业市值降序，每行：产品列为空、股票名称列为行业名、市值、**占比 = 该行业市值 / totalAssets × 100%**。 |
| 7.9 | 用 SheetJS 将上述行转成 sheet「持仓汇总」，生成 xlsx 并下载，文件名带日期。 |

**占比口径**：  
- 产品块内：该产品「持仓 + 现金」为分母。  
- 行业汇总块：全量总资产为分母。

---

## 九、数据汇总逻辑小结表

| 环节 | 汇总维度 | 分子 | 分母 | 说明 |
|------|----------|------|------|------|
| 所有产品汇总 | 全量 | 总市值 / 总现金 / 总资产 | - | 直接加总 holdings + 四产品现金 |
| 行业占比分析 | 行业 | 各行业市值 + 现金 | totalAssets | 按 category 汇总，再加现金一项 |
| 持仓明细（单产品） | 产品 | 该产品每只股票市值、现金 | 该产品 totalAsset | 仅该产品持仓+现金 |
| 持仓明细（全部汇总） | 合并同名 | 同名股票合并市值、总现金 | 全量 totalAsset | 同名字段合并后算占比 |
| Excel 产品块 | 产品 | 每只股票、现金、合计 | 该产品 total | 与页面单产品逻辑一致 |
| Excel 行业汇总 | 行业 | 各行业 + 现金 | 全量 totalAssets | 与页面行业占比一致 |

---

## 十、相关代码位置（持仓整理工具.html）

- 流程入口：`startCalculation()`（约 594 行）  
- OCR 解析：`parseOCRResult()`（约 693 行）  
- 行业映射：`categoryMap`（约 774 行）  
- 主计算：`calculate()`（约 947 行）  
- 行业占比：`renderIndustry()`（约 977 行）  
- 持仓表格：`renderTable()`（约 1062 行）  
- Excel 导出：`exportExcel()`（约 1206 行）  
- 现金：`getCash(p)`、`getTotalCash()`（约 926、934 行）  

以上即为当前程序的完整数据汇总逻辑，可按步骤对照代码核对或调整。
